# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 /opt/local/bin/swig -r -cpperraswarn -outdir /Users/stegle/work/projects/peer/build/R -c++ -I/Users/stegle/work/projects/peer -I/Users/stegle/work/projects/peer/./include -I/Users/stegle/work/projects/peer/./External/alglib/src -I/Users/stegle/work/projects/peer/R/./../External -I/Users/stegle/work/projects/peer/R/./../External/Eigen -I/External/alglib -I/include -I/opt/local/lib/R/include -I/opt/local/lib/R/include/x86_64 -I/opt/local/lib/R/include/i386 -o /Users/stegle/work/projects/peer/build/R/peerR_wrap.cxx /Users/stegle/work/projects/peer/R/peer.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = RSWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################


setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_PEER__cWNodeSparse', contains = 'C++Reference')
setClass('_p_PEER__cEpsNodeSparse', contains = 'C++Reference')
setClass('_p_PEER__cSPARSEFA', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})

# Start of getVerbose

`getVerbose` = function(.copy = FALSE)
{
  ;.Call('R_swig_getVerbose', as.logical(.copy), PACKAGE='peer');
  
}

attr(`getVerbose`, 'returnType') = 'integer'
class(`getVerbose`) = c("SWIGFunction", class('getVerbose'))

# Start of setVerbose

`setVerbose` = function(verbose)
{
  verbose = as.integer(verbose); 
  
  if(length(verbose) > 1) {
    warning("using only the first element of verbose");
  };
  
  ;.Call('R_swig_setVerbose', verbose, PACKAGE='peer');
  
}

attr(`setVerbose`, 'returnType') = 'void'
attr(`setVerbose`, "inputTypes") = c('integer')
class(`setVerbose`) = c("SWIGFunction", class('setVerbose'))

# Start of cWNodeSparse_pi_set

`cWNodeSparse_pi_set` = function(self, s_pi)
{
  ;.Call('R_swig_cWNodeSparse_pi_set', self, s_pi, PACKAGE='peer');
  
}

attr(`cWNodeSparse_pi_set`, 'returnType') = 'void'
attr(`cWNodeSparse_pi_set`, "inputTypes") = c('_p_PEER__cWNodeSparse', '_p_PMatrix')
class(`cWNodeSparse_pi_set`) = c("SWIGFunction", class('cWNodeSparse_pi_set'))

# Start of cWNodeSparse_pi_get

`cWNodeSparse_pi_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cWNodeSparse_pi_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cWNodeSparse_pi_get`, 'returnType') = '_p_PMatrix'
attr(`cWNodeSparse_pi_get`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`cWNodeSparse_pi_get`) = c("SWIGFunction", class('cWNodeSparse_pi_get'))

# Start of cWNodeSparse_lpi_set

`cWNodeSparse_lpi_set` = function(self, s_lpi)
{
  ;.Call('R_swig_cWNodeSparse_lpi_set', self, s_lpi, PACKAGE='peer');
  
}

attr(`cWNodeSparse_lpi_set`, 'returnType') = 'void'
attr(`cWNodeSparse_lpi_set`, "inputTypes") = c('_p_PEER__cWNodeSparse', '_p_PMatrix')
class(`cWNodeSparse_lpi_set`) = c("SWIGFunction", class('cWNodeSparse_lpi_set'))

# Start of cWNodeSparse_lpi_get

`cWNodeSparse_lpi_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cWNodeSparse_lpi_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cWNodeSparse_lpi_get`, 'returnType') = '_p_PMatrix'
attr(`cWNodeSparse_lpi_get`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`cWNodeSparse_lpi_get`) = c("SWIGFunction", class('cWNodeSparse_lpi_get'))

# Start of cWNodeSparse_lpi_off_set

`cWNodeSparse_lpi_off_set` = function(self, s_lpi_off)
{
  ;.Call('R_swig_cWNodeSparse_lpi_off_set', self, s_lpi_off, PACKAGE='peer');
  
}

attr(`cWNodeSparse_lpi_off_set`, 'returnType') = 'void'
attr(`cWNodeSparse_lpi_off_set`, "inputTypes") = c('_p_PEER__cWNodeSparse', '_p_PMatrix')
class(`cWNodeSparse_lpi_off_set`) = c("SWIGFunction", class('cWNodeSparse_lpi_off_set'))

# Start of cWNodeSparse_lpi_off_get

`cWNodeSparse_lpi_off_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cWNodeSparse_lpi_off_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cWNodeSparse_lpi_off_get`, 'returnType') = '_p_PMatrix'
attr(`cWNodeSparse_lpi_off_get`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`cWNodeSparse_lpi_off_get`) = c("SWIGFunction", class('cWNodeSparse_lpi_off_get'))

# Start of cWNodeSparse_C_set

`cWNodeSparse_C_set` = function(self, s_C)
{
  ;.Call('R_swig_cWNodeSparse_C_set', self, s_C, PACKAGE='peer');
  
}

attr(`cWNodeSparse_C_set`, 'returnType') = 'void'
attr(`cWNodeSparse_C_set`, "inputTypes") = c('_p_PEER__cWNodeSparse', '_p_PMatrix')
class(`cWNodeSparse_C_set`) = c("SWIGFunction", class('cWNodeSparse_C_set'))

# Start of cWNodeSparse_C_get

`cWNodeSparse_C_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cWNodeSparse_C_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cWNodeSparse_C_get`, 'returnType') = '_p_PMatrix'
attr(`cWNodeSparse_C_get`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`cWNodeSparse_C_get`) = c("SWIGFunction", class('cWNodeSparse_C_get'))

# Start of cWNodeSparse_Coff_set

`cWNodeSparse_Coff_set` = function(self, s_Coff)
{
  ;.Call('R_swig_cWNodeSparse_Coff_set', self, s_Coff, PACKAGE='peer');
  
}

attr(`cWNodeSparse_Coff_set`, 'returnType') = 'void'
attr(`cWNodeSparse_Coff_set`, "inputTypes") = c('_p_PEER__cWNodeSparse', '_p_PMatrix')
class(`cWNodeSparse_Coff_set`) = c("SWIGFunction", class('cWNodeSparse_Coff_set'))

# Start of cWNodeSparse_Coff_get

`cWNodeSparse_Coff_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cWNodeSparse_Coff_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cWNodeSparse_Coff_get`, 'returnType') = '_p_PMatrix'
attr(`cWNodeSparse_Coff_get`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`cWNodeSparse_Coff_get`) = c("SWIGFunction", class('cWNodeSparse_Coff_get'))

# Start of cWNodeSparse_CovPriorDiag_set

`cWNodeSparse_CovPriorDiag_set` = function(self, s_CovPriorDiag)
{
  ;.Call('R_swig_cWNodeSparse_CovPriorDiag_set', self, s_CovPriorDiag, PACKAGE='peer');
  
}

attr(`cWNodeSparse_CovPriorDiag_set`, 'returnType') = 'void'
attr(`cWNodeSparse_CovPriorDiag_set`, "inputTypes") = c('_p_PEER__cWNodeSparse', '_p_PMatrix')
class(`cWNodeSparse_CovPriorDiag_set`) = c("SWIGFunction", class('cWNodeSparse_CovPriorDiag_set'))

# Start of cWNodeSparse_CovPriorDiag_get

`cWNodeSparse_CovPriorDiag_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cWNodeSparse_CovPriorDiag_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cWNodeSparse_CovPriorDiag_get`, 'returnType') = '_p_PMatrix'
attr(`cWNodeSparse_CovPriorDiag_get`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`cWNodeSparse_CovPriorDiag_get`) = c("SWIGFunction", class('cWNodeSparse_CovPriorDiag_get'))

# Start of cWNodeSparse_tauOn_set

`cWNodeSparse_tauOn_set` = function(self, s_tauOn)
{
  ;.Call('R_swig_cWNodeSparse_tauOn_set', self, s_tauOn, PACKAGE='peer');
  
}

attr(`cWNodeSparse_tauOn_set`, 'returnType') = 'void'
attr(`cWNodeSparse_tauOn_set`, "inputTypes") = c('_p_PEER__cWNodeSparse', 'numeric')
class(`cWNodeSparse_tauOn_set`) = c("SWIGFunction", class('cWNodeSparse_tauOn_set'))

# Start of cWNodeSparse_tauOn_get

`cWNodeSparse_tauOn_get` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_cWNodeSparse_tauOn_get', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`cWNodeSparse_tauOn_get`, 'returnType') = 'numeric'
attr(`cWNodeSparse_tauOn_get`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`cWNodeSparse_tauOn_get`) = c("SWIGFunction", class('cWNodeSparse_tauOn_get'))

# Start of cWNodeSparse_tauOff_set

`cWNodeSparse_tauOff_set` = function(self, s_tauOff)
{
  ;.Call('R_swig_cWNodeSparse_tauOff_set', self, s_tauOff, PACKAGE='peer');
  
}

attr(`cWNodeSparse_tauOff_set`, 'returnType') = 'void'
attr(`cWNodeSparse_tauOff_set`, "inputTypes") = c('_p_PEER__cWNodeSparse', 'numeric')
class(`cWNodeSparse_tauOff_set`) = c("SWIGFunction", class('cWNodeSparse_tauOff_set'))

# Start of cWNodeSparse_tauOff_get

`cWNodeSparse_tauOff_get` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_cWNodeSparse_tauOff_get', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`cWNodeSparse_tauOff_get`, 'returnType') = 'numeric'
attr(`cWNodeSparse_tauOff_get`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`cWNodeSparse_tauOff_get`) = c("SWIGFunction", class('cWNodeSparse_tauOff_get'))

# Start of new_cWNodeSparse

`cWNodeSparse__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_cWNodeSparse__SWIG_0', PACKAGE='peer');
  class(ans) <- "_p_PEER__cWNodeSparse";
  
  reg.finalizer(ans, delete_cWNodeSparse)
  ans
  
}

attr(`cWNodeSparse__SWIG_0`, 'returnType') = '_p_PEER__cWNodeSparse'
class(`cWNodeSparse__SWIG_0`) = c("SWIGFunction", class('cWNodeSparse__SWIG_0'))

# Start of new_cWNodeSparse

`cWNodeSparse__SWIG_1` = function(E1, pi, net)
{
  ;ans = .Call('R_swig_new_cWNodeSparse__SWIG_1', E1, pi, net, PACKAGE='peer');
  class(ans) <- "_p_PEER__cWNodeSparse";
  
  reg.finalizer(ans, delete_cWNodeSparse)
  ans
  
}

attr(`cWNodeSparse__SWIG_1`, 'returnType') = '_p_PEER__cWNodeSparse'
attr(`cWNodeSparse__SWIG_1`, "inputTypes") = c('_p_PMatrix', '_p_PMatrix', '_p_cBayesNet')
class(`cWNodeSparse__SWIG_1`) = c("SWIGFunction", class('cWNodeSparse__SWIG_1'))

`cWNodeSparse` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- cWNodeSparse__SWIG_0; 
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_PMatrix') && extends(argtypes[2], '_p_PMatrix') && extends(argtypes[3], '_p_cBayesNet')) {
      f <- cWNodeSparse__SWIG_1; 
    }
  };
  f(...);
}

# Dispatch function
# Start of cWNodeSparse_update

`cWNodeSparse_update` = function(self, net)
{
  ;.Call('R_swig_cWNodeSparse_update', self, net, PACKAGE='peer');
  
}

attr(`cWNodeSparse_update`, 'returnType') = 'void'
attr(`cWNodeSparse_update`, "inputTypes") = c('_p_PEER__cWNodeSparse', '_p_cBayesNet')
class(`cWNodeSparse_update`) = c("SWIGFunction", class('cWNodeSparse_update'))

# Start of delete_cWNodeSparse

`delete_cWNodeSparse` = function(self)
{
  ;.Call('R_swig_delete_cWNodeSparse', self, PACKAGE='peer');
  
}

attr(`delete_cWNodeSparse`, 'returnType') = 'void'
attr(`delete_cWNodeSparse`, "inputTypes") = c('_p_PEER__cWNodeSparse')
class(`delete_cWNodeSparse`) = c("SWIGFunction", class('delete_cWNodeSparse'))

# Start of accessor method for PEER::cWNodeSparse
setMethod('$', '_p_PEER__cWNodeSparse', function(x, name)

{
  accessorFuns = list('pi' = cWNodeSparse_pi_get, 'lpi' = cWNodeSparse_lpi_get, 'lpi_off' = cWNodeSparse_lpi_off_get, 'C' = cWNodeSparse_C_get, 'Coff' = cWNodeSparse_Coff_get, 'CovPriorDiag' = cWNodeSparse_CovPriorDiag_get, 'tauOn' = cWNodeSparse_tauOn_get, 'tauOff' = cWNodeSparse_tauOff_get, 'update' = cWNodeSparse_update);
  vaccessors = c('pi', 'lpi', 'lpi_off', 'C', 'Coff', 'CovPriorDiag', 'tauOn', 'tauOff');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  if (is.na(match(name, vaccessors))) f else f(x);
}


);
# end of accessor method for PEER::cWNodeSparse
# Start of accessor method for PEER::cWNodeSparse
setMethod('$<-', '_p_PEER__cWNodeSparse', function(x, name, value)

{
  accessorFuns = list('pi' = cWNodeSparse_pi_set, 'lpi' = cWNodeSparse_lpi_set, 'lpi_off' = cWNodeSparse_lpi_off_set, 'C' = cWNodeSparse_C_set, 'Coff' = cWNodeSparse_Coff_set, 'CovPriorDiag' = cWNodeSparse_CovPriorDiag_set, 'tauOn' = cWNodeSparse_tauOn_set, 'tauOff' = cWNodeSparse_tauOff_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PEER__cWNodeSparse', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('pi' = cWNodeSparse_pi_set, 'lpi' = cWNodeSparse_lpi_set, 'lpi_off' = cWNodeSparse_lpi_off_set, 'C' = cWNodeSparse_C_set, 'Coff' = cWNodeSparse_Coff_set, 'CovPriorDiag' = cWNodeSparse_CovPriorDiag_set, 'tauOn' = cWNodeSparse_tauOn_set, 'tauOff' = cWNodeSparse_tauOff_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for PEER::cWNodeSparse
setMethod('delete', '_p_PEER__cWNodeSparse', function(obj) {delete_PEER__cWNodeSparse(obj)})
# Start of new_cEpsNodeSparse

`cEpsNodeSparse` = function(dim, pa, pb, E1)
{
  dim = as.integer(dim); 
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_cEpsNodeSparse', dim, pa, pb, E1, PACKAGE='peer');
  class(ans) <- "_p_PEER__cEpsNodeSparse";
  
  reg.finalizer(ans, delete_cEpsNodeSparse)
  ans
  
}

attr(`cEpsNodeSparse`, 'returnType') = '_p_PEER__cEpsNodeSparse'
attr(`cEpsNodeSparse`, "inputTypes") = c('integer', 'numeric', 'numeric', '_p_PMatrix')
class(`cEpsNodeSparse`) = c("SWIGFunction", class('cEpsNodeSparse'))

# Start of cEpsNodeSparse_update

`cEpsNodeSparse_update` = function(self, net)
{
  ;.Call('R_swig_cEpsNodeSparse_update', self, net, PACKAGE='peer');
  
}

attr(`cEpsNodeSparse_update`, 'returnType') = 'void'
attr(`cEpsNodeSparse_update`, "inputTypes") = c('_p_PEER__cEpsNodeSparse', '_p_cBayesNet')
class(`cEpsNodeSparse_update`) = c("SWIGFunction", class('cEpsNodeSparse_update'))

# Start of delete_cEpsNodeSparse

`delete_cEpsNodeSparse` = function(self)
{
  ;.Call('R_swig_delete_cEpsNodeSparse', self, PACKAGE='peer');
  
}

attr(`delete_cEpsNodeSparse`, 'returnType') = 'void'
attr(`delete_cEpsNodeSparse`, "inputTypes") = c('_p_PEER__cEpsNodeSparse')
class(`delete_cEpsNodeSparse`) = c("SWIGFunction", class('delete_cEpsNodeSparse'))

# Start of accessor method for PEER::cEpsNodeSparse
setMethod('$', '_p_PEER__cEpsNodeSparse', function(x, name)

{
  accessorFuns = list('update' = cEpsNodeSparse_update);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PEER::cEpsNodeSparse
setMethod('delete', '_p_PEER__cEpsNodeSparse', function(obj) {delete_PEER__cEpsNodeSparse(obj)})
# Start of new_PEER

`PEER` = function()
{
  ;ans = .Call('R_swig_new_PEER', PACKAGE='peer');
  class(ans) <- "_p_PEER__cSPARSEFA";
  
  reg.finalizer(ans, delete_PEER)
  ans
  
}

attr(`PEER`, 'returnType') = '_p_PEER__cSPARSEFA'
class(`PEER`) = c("SWIGFunction", class('PEER'))

# Start of delete_PEER

`delete_PEER` = function(self)
{
  ;.Call('R_swig_delete_PEER', self, PACKAGE='peer');
  
}

attr(`delete_PEER`, 'returnType') = 'void'
attr(`delete_PEER`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`delete_PEER`) = c("SWIGFunction", class('delete_PEER'))

# Start of PEER_setSigmaOff

`PEER_setSigmaOff` = function(self, sigma_off)
{
  ;.Call('R_swig_PEER_setSigmaOff', self, sigma_off, PACKAGE='peer');
  
}

attr(`PEER_setSigmaOff`, 'returnType') = 'void'
attr(`PEER_setSigmaOff`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric')
class(`PEER_setSigmaOff`) = c("SWIGFunction", class('PEER_setSigmaOff'))

# Start of PEER_getSigmaOff

`PEER_getSigmaOff` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_PEER_getSigmaOff', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`PEER_getSigmaOff`, 'returnType') = 'numeric'
attr(`PEER_getSigmaOff`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getSigmaOff`) = c("SWIGFunction", class('PEER_getSigmaOff'))

# Start of PEER_setSparsityPrior

`PEER_setSparsityPrior` = function(self, matrix)
{
  ;.Call('R_swig_PEER_setSparsityPrior', self, matrix, PACKAGE='peer');
  
}

attr(`PEER_setSparsityPrior`, 'returnType') = 'void'
attr(`PEER_setSparsityPrior`, "inputTypes") = c('_p_PEER__cSPARSEFA', '_p_float64_t')
class(`PEER_setSparsityPrior`) = c("SWIGFunction", class('PEER_setSparsityPrior'))

# Start of PEER_getSparsityPrior

`PEER_getSparsityPrior` = function(self)
{
  ;.Call('R_swig_PEER_getSparsityPrior', self, PACKAGE='peer');
  
}

attr(`PEER_getSparsityPrior`, 'returnType') = 'void'
attr(`PEER_getSparsityPrior`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getSparsityPrior`) = c("SWIGFunction", class('PEER_getSparsityPrior'))

# Start of PEER_getZ

`PEER_getZ` = function(self)
{
  ;.Call('R_swig_PEER_getZ', self, PACKAGE='peer');
  
}

attr(`PEER_getZ`, 'returnType') = 'void'
attr(`PEER_getZ`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getZ`) = c("SWIGFunction", class('PEER_getZ'))

# Start of PEER_setNk

`PEER_setNk` = function(self, Nk)
{
  Nk = as.integer(Nk); 
  
  if(length(Nk) > 1) {
    warning("using only the first element of Nk");
  };
  
  ;.Call('R_swig_PEER_setNk', self, Nk, PACKAGE='peer');
  
}

attr(`PEER_setNk`, 'returnType') = 'void'
attr(`PEER_setNk`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'integer')
class(`PEER_setNk`) = c("SWIGFunction", class('PEER_setNk'))

# Start of PEER_setAdd_mean

`PEER_setAdd_mean` = function(self, add_mean)
{
  add_mean = as.logical(add_mean);
  ;.Call('R_swig_PEER_setAdd_mean', self, add_mean, PACKAGE='peer');
  
}

attr(`PEER_setAdd_mean`, 'returnType') = 'void'
attr(`PEER_setAdd_mean`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'logical')
class(`PEER_setAdd_mean`) = c("SWIGFunction", class('PEER_setAdd_mean'))

# Start of PEER_setNmax_iterations

`PEER_setNmax_iterations` = function(self, Nmax_iterations)
{
  Nmax_iterations = as.integer(Nmax_iterations); 
  
  if(length(Nmax_iterations) > 1) {
    warning("using only the first element of Nmax_iterations");
  };
  
  ;.Call('R_swig_PEER_setNmax_iterations', self, Nmax_iterations, PACKAGE='peer');
  
}

attr(`PEER_setNmax_iterations`, 'returnType') = 'void'
attr(`PEER_setNmax_iterations`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'integer')
class(`PEER_setNmax_iterations`) = c("SWIGFunction", class('PEER_setNmax_iterations'))

# Start of PEER_setTolerance

`PEER_setTolerance` = function(self, tolerance)
{
  ;.Call('R_swig_PEER_setTolerance', self, tolerance, PACKAGE='peer');
  
}

attr(`PEER_setTolerance`, 'returnType') = 'void'
attr(`PEER_setTolerance`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric')
class(`PEER_setTolerance`) = c("SWIGFunction", class('PEER_setTolerance'))

# Start of PEER_setVarTolerance

`PEER_setVarTolerance` = function(self, tolerance)
{
  ;.Call('R_swig_PEER_setVarTolerance', self, tolerance, PACKAGE='peer');
  
}

attr(`PEER_setVarTolerance`, 'returnType') = 'void'
attr(`PEER_setVarTolerance`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric')
class(`PEER_setVarTolerance`) = c("SWIGFunction", class('PEER_setVarTolerance'))

# Start of PEER_setPriorAlphaA

`PEER_setPriorAlphaA` = function(self, pa)
{
  ;.Call('R_swig_PEER_setPriorAlphaA', self, pa, PACKAGE='peer');
  
}

attr(`PEER_setPriorAlphaA`, 'returnType') = 'void'
attr(`PEER_setPriorAlphaA`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric')
class(`PEER_setPriorAlphaA`) = c("SWIGFunction", class('PEER_setPriorAlphaA'))

# Start of PEER_setPriorAlphaB

`PEER_setPriorAlphaB` = function(self, pb)
{
  ;.Call('R_swig_PEER_setPriorAlphaB', self, pb, PACKAGE='peer');
  
}

attr(`PEER_setPriorAlphaB`, 'returnType') = 'void'
attr(`PEER_setPriorAlphaB`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric')
class(`PEER_setPriorAlphaB`) = c("SWIGFunction", class('PEER_setPriorAlphaB'))

# Start of PEER_setPriorEpsA

`PEER_setPriorEpsA` = function(self, pa)
{
  ;.Call('R_swig_PEER_setPriorEpsA', self, pa, PACKAGE='peer');
  
}

attr(`PEER_setPriorEpsA`, 'returnType') = 'void'
attr(`PEER_setPriorEpsA`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric')
class(`PEER_setPriorEpsA`) = c("SWIGFunction", class('PEER_setPriorEpsA'))

# Start of PEER_setPriorEpsB

`PEER_setPriorEpsB` = function(self, pb)
{
  ;.Call('R_swig_PEER_setPriorEpsB', self, pb, PACKAGE='peer');
  
}

attr(`PEER_setPriorEpsB`, 'returnType') = 'void'
attr(`PEER_setPriorEpsB`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric')
class(`PEER_setPriorEpsB`) = c("SWIGFunction", class('PEER_setPriorEpsB'))

# Start of PEER_setPriorAlpha

`PEER_setPriorAlpha` = function(self, pa, pb)
{
  ;.Call('R_swig_PEER_setPriorAlpha', self, pa, pb, PACKAGE='peer');
  
}

attr(`PEER_setPriorAlpha`, 'returnType') = 'void'
attr(`PEER_setPriorAlpha`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric', 'numeric')
class(`PEER_setPriorAlpha`) = c("SWIGFunction", class('PEER_setPriorAlpha'))

# Start of PEER_setPriorEps

`PEER_setPriorEps` = function(self, pa, pb)
{
  ;.Call('R_swig_PEER_setPriorEps', self, pa, pb, PACKAGE='peer');
  
}

attr(`PEER_setPriorEps`, 'returnType') = 'void'
attr(`PEER_setPriorEps`, "inputTypes") = c('_p_PEER__cSPARSEFA', 'numeric', 'numeric')
class(`PEER_setPriorEps`) = c("SWIGFunction", class('PEER_setPriorEps'))

# Start of PEER_init_net

`PEER_init_net` = function(self)
{
  ;.Call('R_swig_PEER_init_net', self, PACKAGE='peer');
  
}

attr(`PEER_init_net`, 'returnType') = 'void'
attr(`PEER_init_net`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_init_net`) = c("SWIGFunction", class('PEER_init_net'))

# Start of PEER_calcBound

`PEER_calcBound` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_PEER_calcBound', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`PEER_calcBound`, 'returnType') = 'numeric'
attr(`PEER_calcBound`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_calcBound`) = c("SWIGFunction", class('PEER_calcBound'))

# Start of PEER_logprob

`PEER_logprob` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_PEER_logprob', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`PEER_logprob`, 'returnType') = 'numeric'
attr(`PEER_logprob`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_logprob`) = c("SWIGFunction", class('PEER_logprob'))

# Start of PEER_update

`PEER_update` = function(self)
{
  ;.Call('R_swig_PEER_update', self, PACKAGE='peer');
  
}

attr(`PEER_update`, 'returnType') = 'void'
attr(`PEER_update`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_update`) = c("SWIGFunction", class('PEER_update'))

# Start of PEER_setPhenoMean

`PEER_setPhenoMean` = function(self, matrix)
{
  ;.Call('R_swig_PEER_setPhenoMean', self, matrix, PACKAGE='peer');
  
}

attr(`PEER_setPhenoMean`, 'returnType') = 'void'
attr(`PEER_setPhenoMean`, "inputTypes") = c('_p_PEER__cSPARSEFA', '_p_float64_t')
class(`PEER_setPhenoMean`) = c("SWIGFunction", class('PEER_setPhenoMean'))

# Start of PEER_setPhenoVar

`PEER_setPhenoVar` = function(self, matrix)
{
  ;.Call('R_swig_PEER_setPhenoVar', self, matrix, PACKAGE='peer');
  
}

attr(`PEER_setPhenoVar`, 'returnType') = 'void'
attr(`PEER_setPhenoVar`, "inputTypes") = c('_p_PEER__cSPARSEFA', '_p_float64_t')
class(`PEER_setPhenoVar`) = c("SWIGFunction", class('PEER_setPhenoVar'))

# Start of PEER_setCovariates

`PEER_setCovariates` = function(self, matrix)
{
  ;.Call('R_swig_PEER_setCovariates', self, matrix, PACKAGE='peer');
  
}

attr(`PEER_setCovariates`, 'returnType') = 'void'
attr(`PEER_setCovariates`, "inputTypes") = c('_p_PEER__cSPARSEFA', '_p_float64_t')
class(`PEER_setCovariates`) = c("SWIGFunction", class('PEER_setCovariates'))

# Start of PEER_getPhenoMean

`PEER_getPhenoMean` = function(self)
{
  ;.Call('R_swig_PEER_getPhenoMean', self, PACKAGE='peer');
  
}

attr(`PEER_getPhenoMean`, 'returnType') = 'void'
attr(`PEER_getPhenoMean`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getPhenoMean`) = c("SWIGFunction", class('PEER_getPhenoMean'))

# Start of PEER_getPhenoVar

`PEER_getPhenoVar` = function(self)
{
  ;.Call('R_swig_PEER_getPhenoVar', self, PACKAGE='peer');
  
}

attr(`PEER_getPhenoVar`, 'returnType') = 'void'
attr(`PEER_getPhenoVar`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getPhenoVar`) = c("SWIGFunction", class('PEER_getPhenoVar'))

# Start of PEER_getCovariates

`PEER_getCovariates` = function(self)
{
  ;.Call('R_swig_PEER_getCovariates', self, PACKAGE='peer');
  
}

attr(`PEER_getCovariates`, 'returnType') = 'void'
attr(`PEER_getCovariates`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getCovariates`) = c("SWIGFunction", class('PEER_getCovariates'))

# Start of PEER_getX

`PEER_getX` = function(self)
{
  ;.Call('R_swig_PEER_getX', self, PACKAGE='peer');
  
}

attr(`PEER_getX`, 'returnType') = 'void'
attr(`PEER_getX`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getX`) = c("SWIGFunction", class('PEER_getX'))

# Start of PEER_getW

`PEER_getW` = function(self)
{
  ;.Call('R_swig_PEER_getW', self, PACKAGE='peer');
  
}

attr(`PEER_getW`, 'returnType') = 'void'
attr(`PEER_getW`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getW`) = c("SWIGFunction", class('PEER_getW'))

# Start of PEER_getEps

`PEER_getEps` = function(self)
{
  ;.Call('R_swig_PEER_getEps', self, PACKAGE='peer');
  
}

attr(`PEER_getEps`, 'returnType') = 'void'
attr(`PEER_getEps`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getEps`) = c("SWIGFunction", class('PEER_getEps'))

# Start of PEER_getAlpha

`PEER_getAlpha` = function(self)
{
  ;.Call('R_swig_PEER_getAlpha', self, PACKAGE='peer');
  
}

attr(`PEER_getAlpha`, 'returnType') = 'void'
attr(`PEER_getAlpha`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getAlpha`) = c("SWIGFunction", class('PEER_getAlpha'))

# Start of PEER_getResiduals

`PEER_getResiduals` = function(self)
{
  ;.Call('R_swig_PEER_getResiduals', self, PACKAGE='peer');
  
}

attr(`PEER_getResiduals`, 'returnType') = 'void'
attr(`PEER_getResiduals`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_getResiduals`) = c("SWIGFunction", class('PEER_getResiduals'))

# Start of PEER_init_net_sparse

`PEER_init_net_sparse` = function(self)
{
  ;.Call('R_swig_PEER_init_net_sparse', self, PACKAGE='peer');
  
}

attr(`PEER_init_net_sparse`, 'returnType') = 'void'
attr(`PEER_init_net_sparse`, "inputTypes") = c('_p_PEER__cSPARSEFA')
class(`PEER_init_net_sparse`) = c("SWIGFunction", class('PEER_init_net_sparse'))

# Start of accessor method for PEER::cSPARSEFA
setMethod('$', '_p_PEER__cSPARSEFA', function(x, name)

{
  accessorFuns = list('setSigmaOff' = PEER_setSigmaOff, 'getSigmaOff' = PEER_getSigmaOff, 'setSparsityPrior' = PEER_setSparsityPrior, 'getSparsityPrior' = PEER_getSparsityPrior, 'getZ' = PEER_getZ, 'setNk' = PEER_setNk, 'setAdd_mean' = PEER_setAdd_mean, 'setNmax_iterations' = PEER_setNmax_iterations, 'setTolerance' = PEER_setTolerance, 'setVarTolerance' = PEER_setVarTolerance, 'setPriorAlphaA' = PEER_setPriorAlphaA, 'setPriorAlphaB' = PEER_setPriorAlphaB, 'setPriorEpsA' = PEER_setPriorEpsA, 'setPriorEpsB' = PEER_setPriorEpsB, 'setPriorAlpha' = PEER_setPriorAlpha, 'setPriorEps' = PEER_setPriorEps, 'init_net' = PEER_init_net, 'calcBound' = PEER_calcBound, 'logprob' = PEER_logprob, 'update' = PEER_update, 'setPhenoMean' = PEER_setPhenoMean, 'setPhenoVar' = PEER_setPhenoVar, 'setCovariates' = PEER_setCovariates, 'getPhenoMean' = PEER_getPhenoMean, 'getPhenoVar' = PEER_getPhenoVar, 'getCovariates' = PEER_getCovariates, 'getX' = PEER_getX, 'getW' = PEER_getW, 'getEps' = PEER_getEps, 'getAlpha' = PEER_getAlpha, 'getResiduals' = PEER_getResiduals, 'init_net_sparse' = PEER_init_net_sparse);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PEER::cSPARSEFA
setMethod('delete', '_p_PEER__cSPARSEFA', function(obj) {delete_PEER__cSPARSEFA(obj)})

